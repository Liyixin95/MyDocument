= 依赖注入——实现部分

== 前置知识

这里列举的知识点是二期框架中实现依赖注入必备的知识，如果有不清楚的请自行学习。

. 图论基础
.. 基本术语
.. 基本算法（深搜，广搜，拓扑排序）

. 字节码基础
.. JVM 指令集及其执行过程
.. class文件结构
.. ASM 字节码生成工具

. 注解处理器
.. 注解处理器的基本使用
.. Java 抽象语法树

WARNING: 如果上述词语你一个都不认识，那么请先关掉此文档去学习相应知识，强行往下看只是浪费时间。

== 总体设计

依赖注入模块被分为了两个大的平面，分别是编译期平面与运行期平面。编译期关注注解到配置文件的转化、代码生成、Bean有效性校验等。运行期则关注Bean的加载、构造、组装等。

这样设计的目的是将依赖注入的使用与实现解耦。运行期不直接依赖使用方式 （注解配置，配置文件配置，代码配置等），而是依赖于一组基础的依赖注入原语，而编译期则负责将具体的使用方式翻译成底层的原语。这两者的关系可以类比于Java和字节码的关系。

== 运行期设计

=== 需求分析
==== 加载
加载首先需要按需加载，即不会像现在这样初始化的时候就将所有的类都加载进来，而是等到实际使用
到的时候才加载类。这样在性能测试环境下会有一定优势。

其次需要支持隐式刷新，即运行时添加了新的代码，要能自动的加载进去。注意这里和热替换不一样，只是新增了代码，不是修改了原有的代码。

==== 检索
检索是功能方面的重点，需要支持按类检索、按Bean名字检索、按限定符检索等。

但是对于运行期而言，这些可以被归约为两点，即按主键检索和按索引检索。一个Bean拥有唯一的声明类型，所以声明类型作为主键，其余的类型、限定符、Stereotype等均作为索引。

==== 类型系统
既然声明类型作为Bean的主键，那么自然要考虑参数化类型的问题。类型参数的特化交由编译期处理，运行期的任务就是识别参数化类型，即识别 ``List<Integer>``和``List<String>``。

其次，为了避免产生大量的重复实例，类型的实例需要有缓存。这样一来就引入了新的问题，即热替换可能造成的类型失效。鉴于这个问题还比较遥远，目前暂不考虑。

==== 实例化
实例化首先需要的是组装。组装Bean的过程是编译期生成的，运行期不需考虑。而Scope、回调则是运行期插到组装过程中。其次实例化需要考虑线程安全。

=== 类设计

=== 流程设计